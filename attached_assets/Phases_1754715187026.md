### Phase 1

Attention Replit AI Agent:

This directive outlines the strategic implementation of a sophisticated Gmail Finance Manager application, codenamed "DataBerry". Your primary objective is to develop and deploy this application within the Replit environment, adhering to the architectural and functional specifications detailed below. This initiative is designed to empower a multi-faceted professional who operates as an Accounting Technician, Administrative Assistant, Language Practitioner, and Low-Code Developer.

I. High-Level Strategic Overview

The "DataBerry" platform will serve as a centralized hub for the automated extraction, categorization, and management of financial documents from a user's Gmail account. The overarching goal is to streamline financial workflows, enhance data visibility, and drive operational efficiency.

II. Architectural Blueprint

The application will be built upon a strategically distributed architecture to leverage the optimal platform for each component:

- Front-End & Back-End Application Logic: To be hosted on the Render platform.
- Database: A Google Cloud SQL for PostgreSQL instance will serve as the primary data store.
- Data Processing (ETL): All email processing, including data extraction and metadata enrichment, will be handled by a Google Apps Script. Your role is to build the application that will interface with the data processed by this script, not to replicate the script's functionality.

III. Core Functionality & Feature Set

You are tasked with building the user-facing application with the following core features:

- Dashboard & Data Visualization:

- A main dashboard to provide a high-level overview of key financial metrics.
- Simple, clean charts and graphs to visualize financial trends.

- Data Management & Operations:

- A table-based view of all processed financial documents (receipts, bills, invoices, etc.).
- Advanced filtering and sorting capabilities by date, sender, label, and category.
- The ability to manually add, edit, and delete financial records.

- User & Label Management:

- A simple interface for managing user access.
- A system for creating, editing, and deleting custom labels to categorize financial documents.

- Data Export:

- Functionality to export filtered data to a CSV file.

IV. User-Centric Design Considerations

The application must be designed with the following user personas in mind:

- As an Accounting Technician: I need to be able to quickly access, filter, and export financial data for accounting and tax purposes. The application should provide a clear and accurate view of all financial transactions.
- As an Administrative Assistant: I need to be able to easily manage and organize financial documents, track expenses, and generate reports for administrative tasks.
- As a Language Practitioner: I may need to process invoices and financial documents in multiple languages. The application should be designed with i18n (internationalization) in mind for future enhancements.
- As a Low-Code Developer: I will be maintaining and extending the application. The code should be well-structured, commented, and easy to understand.

V. "Checkpoint-Aware" Development Protocol

To ensure this project remains within the scope of the Replit Starter Plan, you must adhere to the following "checkpoint-aware" development protocol:

1. Phased Implementation: We will approach this project in a phased manner. I will provide you with specific instructions for each phase. Do not proceed to the next phase until I give you the explicit command to do so.
2. Explicit Confirmation: Before you generate any code that will result in a "checkpoint," you must first present me with a clear and concise plan of action. This plan should detail the files you will create or modify and the changes you intend to make. I will then approve this plan before you proceed.
3. Minimal Viable Product (MVP) Focus: Our initial focus will be on building a core, functional MVP. We will prioritize the most critical features first and iterate on them. Avoid adding any "bells and whistles" that are not explicitly requested.
4. One Feature at a Time: We will build one feature at a time. For example, we will first focus on setting up the basic application structure, then move on to the database connection, then the dashboard, and so on.

VI. Initial Task

Your first task is to create the basic file structure for a new Next.js application with TypeScript. Do not install any dependencies or generate any code beyond the initial file structure. Present me with the proposed file structure before you create it.

---

### Phase 2

Attention Replit AI Agent:

We will now proceed to the next critical phase: establishing connectivity with the Google Cloud SQL for PostgreSQL database.

I. Strategic Objective

Your task is to implement the necessary code to connect the Next.js application to our external PostgreSQL database. This will form the data backbone of our application, enabling all subsequent data-driven features.

II. Technical Specifications

You are to perform the following actions:

1. Install Dependencies: Add and install the pg package, which is the Node.js driver for PostgreSQL.
2. Create Database Configuration: Create a new file at lib/db.ts. This file will contain the database connection logic.
3. Implement Connection Logic: Within lib/db.ts, you will:

- Import the Pool class from the pg package.
- Create a new instance of Pool.
- The configuration for the Pool will be sourced from environment variables (process.env). You will use placeholders for the following credentials:

- POSTGRES_USER
- POSTGRES_HOST
- POSTGRES_DATABASE
- POSTGRES_PASSWORD
- POSTGRES_PORT

- Export the pool instance so it can be used throughout the application.

III. "Checkpoint-Aware" Protocol

As per our established protocol, you must adhere to the following:

1. Present Your Plan: Before writing any code, present me with a plan detailing the commands you will run to install the dependency and the exact code you will add to the lib/db.ts file.
2. Await Approval: Do not proceed with the implementation until I have reviewed and approved your plan.

IV. A Note on Security

For security purposes, I will provide the actual database credentials as environment variables in a later step. You are only to implement the code that reads these variables. Do not hardcode any credentials.

---
### Phase 3

Attention Replit AI Agent:

With the database connection successfully established, we will now architect the core data schema. This phase is critical, as it will define the structure of our application's data layer and underpin all future functionality.

I. Strategic Objective

Your primary task is to define the PostgreSQL table schemas using Drizzle ORM. This will create a clear, typed, and maintainable data structure that aligns with the application's requirements as a Gmail Finance Manager. The schema must be robust enough to support the needs of an Accounting Technician and Administrative Assistant while being extensible for a Low-Code Developer.

II. Technical Specifications

You are to implement the following within a new file located at lib/schema.ts:

1. Import Necessary Modules: Import the required functions and types from drizzle-orm/pg-core (e.g., pgTable, serial, text, varchar, timestamp, jsonb, boolean, integer).
2. Define Table Schemas: Create the following tables with the specified columns and types. This structure is designed to capture all relevant financial data points from processed emails.

- users table:

- id: serial('id').primaryKey()
- name: varchar('name', { length: 256 })
- email: varchar('email', { length: 256 }).notNull().unique()
- avatarUrl: text('avatar_url')
- createdAt: timestamp('created_at').defaultNow().notNull()

- labels table:

- id: serial('id').primaryKey()
- name: varchar('name', { length: 256 }).notNull()
- color: varchar('color', { length: 7 }) // For hex color codes
- userId: integer('user_id').references(() => users.id)

- emails table:

- id: serial('id').primaryKey()
- messageId: varchar('message_id', { length: 256 }).notNull().unique()
- from: jsonb('from').notNull()
- subject: text('subject')
- body: text('body')
- receivedAt: timestamp('received_at').notNull()
- isRead: boolean('is_read').default(false)
- userId: integer('user_id').references(() => users.id)

- email_labels (Junction Table):

- emailId: integer('email_id').references(() => emails.id)
- labelId: integer('label_id').references(() => labels.id)

- attachments table:

- id: serial('id').primaryKey()
- filename: text('filename').notNull()
- mimeType: varchar('mime_type', { length: 256 })
- size: integer('size') // Size in bytes
- driveUrl: text('drive_url') // Link to the file in Google Drive
- emailId: integer('email_id').references(() => emails.id)

III. "Checkpoint-Aware" Protocol

As per our established workflow:

1. Present Your Plan: Before you write any code, provide a summary of the file you will create and the Drizzle ORM schema definitions you intend to implement.
2. Await Approval: I will review your proposed schema to ensure it aligns with our strategic objectives before you proceed with the implementation.

---

### Phase 4

Attention Replit AI Agent:

Having defined the application's data architecture, our next strategic imperative is to construct the primary user interface (UI). This phase will create the visual scaffolding and dashboard layout that will serve as the user's primary interaction point with the "DataBerry" platform. The design must be intuitive for an Administrative Assistant, data-centric for an Accounting Technician, and easily extensible for a Low-Code Developer.

Crucially, this implementation must strictly adhere to the brand identity and visual style established in the reference attachments.

I. Strategic Objective

Your mission is to build the main application layout using Tailwind CSS and to create the initial dashboard view, replicating the modern, gradient-rich, dark-theme aesthetic shown in the provided screenshots.

II. Visual Design & Branding Mandate

Before implementing any components, you must first configure the application's design system based on the following assets:

1. Color Palette (Reference: 1752568649408_1753356371508.jpg):

- Update the tailwind.config.ts file to include the specified brand colors.
- The primary color family is a gradient of deep purple to a vibrant pink/magenta.
- The background and card colors are dark grays and near-blacks.
- Ensure all UI elements (buttons, text, highlights, charts) utilize this exact color scheme.

2. App Icon (Reference: LB_1_1753356389889.png):

- Integrate the provided "B" logo into the top of the sidebar component. This serves as the primary brand anchor.

3. Overall Style (Reference: All screenshot attachments):

- The application must be built with a dark theme as the default and only theme.
- Utilize gradients extensively for primary actions, highlights, and decorative elements as shown in the screenshots.
- The layout is card-based, with distinct, rounded-corner cards for different sections of content.
- Pay close attention to typography, spacing, and icon usage to match the clean, modern aesthetic of the reference designs.

III. Technical Specifications

Based on the above design mandate, you are to implement the following UI components:

1. Main Layout (components/layout.tsx):

- Create a main layout component that orchestrates the sidebar, header, and main content area.

2. Responsive Sidebar (components/sidebar.tsx):

- The sidebar should be collapsible and feature the app icon at the top.
- It should contain placeholder navigation links for: Dashboard, Emails, Contacts, Labels, and Settings, styled consistently with the screenshots.

3. Header (components/header.tsx):

- The header will display the current page title and a placeholder for a user profile avatar.

4. Dashboard Page (app/dashboard/page.tsx):

- Utilize the main layout to structure the page.
- The content area should feature a grid of "stat cards" (components/stat-card.tsx).
- Create four placeholder stat cards that match the design (including gradient backgrounds and icons) for: Total Emails Processed, Uncategorized Emails, Total Financial Documents, and Monthly Expenses.

IV. "Checkpoint-Aware" Protocol

In alignment with our established operational framework:

1. Present Your Plan: Before implementation, provide a detailed plan. This must include the intended modifications to tailwind.config.ts and an outline of the new components you will create, describing how their structure and styling will meet the visual requirements.
2. Await Approval: I will review your plan to ensure it fully aligns with our brand and design goals before you proceed to generate the code.

---
### Phase 5

Attention Replit AI Agent:

The application's visual foundation is now in place and aligned with our brand identity. The next logical step in our value chain is to bring the interface to life by populating it with dynamic data. This phase will focus on creating the systems to fetch and display the core financial email data, which is a critical function for both the Accounting Technician and Administrative Assistant personas.

I. Strategic Objective

Your mission is to implement an API endpoint that serves mock email data and then to create a dynamic, sortable, and filterable table on the front end to display this data. The final output must mirror the clean, modern, and data-rich table design seen in the reference screenshots (screenshot-1753356945441.jpg, screenshot-1753357116418.jpg).

II. Technical Specifications

You are to execute the following technical tasks:

1. Create a Mock API Endpoint (app/api/emails/route.ts):

- Create a new API route in Next.js.
- This endpoint will return a hardcoded JSON array of sample email data. Each object in the array should conform to the emails schema we defined in Phase 3, including fields like id, from, subject, body, and receivedAt.
- This mock data will serve as our temporary data source until we integrate with the live database.

2. Develop a Reusable Data Table Component (components/data-table.tsx):

- Build a generic, reusable data table component using a library like tanstack/react-table.
- This component should be highly configurable, accepting columns and data as props.
- Implement features for sorting by column and a global text-based filter.
- The styling must be 100% consistent with the reference screenshots, including the dark theme, subtle hover effects, and spacing.

3. Implement the Emails Page (app/emails/page.tsx):

- Create a new page to display the list of financial emails.
- On this page, fetch the data from the /api/emails endpoint you created.
- Use the data-table component to render the fetched email data.
- Define the columns for the table, which should include: Sender, Subject, a Snippet of the body, and the Date Received.

III. "Checkpoint-Aware" Protocol

As per our established operational framework, you must proceed with caution and precision:

1. Present Your Plan: Before writing any code, submit a detailed plan. This plan must outline the structure of the mock API response, the props and core logic for the data-table component, and how the emails page will orchestrate these elements.
2. Await Approval: I will conduct a strategic review of your plan to ensure it aligns with our project goals and technical architecture before authorizing you to proceed with the implementation.

---

### Phase 6

Attention Replit AI Agent:

We have successfully established the visual and data display foundations of the "DataBerry" platform. Our next strategic move is to transform this static display into a dynamic, user-centric workspace. This phase will introduce user authentication and the core organizational feature: interactive labeling. This directly empowers the Accounting Technician and Administrative Assistant personas by enabling them to categorize and manage their financial data according to their unique workflows.

I. Strategic Objective

Your mission is to integrate a secure authentication system and build the full CRUD (Create, Read, Update, Delete) functionality for managing labels. This will involve replacing our mock data source with live database interactions and allowing authenticated users to apply custom labels to their financial emails directly within the data table.

II. Technical Specifications

You are to implement the following a-synchronous, multi-threaded functionalities:

1. Implement Google OAuth (next-auth):

- Integrate the next-auth library to handle user authentication via Google.
- Create the necessary API routes under app/api/auth/[...nextauth]/route.ts to manage the OAuth flow, session creation, and user data persistence in our users table.
- Update the UI:

- The header should display a "Login" or "Sign In" button when the user is unauthenticated.
- Upon successful authentication, the header should display the user's name and avatar, fetched from their Google profile.

2. Live Database Integration:

- Decommission the mock API: Remove the /api/emails route that serves hardcoded data.
- Activate Drizzle ORM: All data operations from this point forward must interact with the live PostgreSQL database using our Drizzle schema. Create a new API endpoint (app/api/emails/route.ts) that fetches emails from the database for the currently authenticated user.

3. Full-Stack Label Management:

- API Endpoints: Create the necessary API routes for full CRUD functionality on the labels table, ensuring all operations are scoped to the authenticated user.
- Label Management Page (app/labels/page.tsx):

- Create a new page where users can view, create, edit, and delete their custom labels.
- Utilize our reusable data-table component to display the list of labels.
- Include a form (perhaps in a modal or drawer) for creating and editing labels, allowing the user to specify a name and select a color.

- Interactive Labeling in Email Table:

- In the emails data table, add a new column.
- This column will contain a popover or dropdown menu for each email row.
- This menu will display a list of the user's available labels (with checkboxes) and allow them to apply or remove labels for that specific email. This action will create or delete records in the email_labels junction table.

III. "Checkpoint-Aware" Protocol

As we escalate the complexity of our operations, adherence to our protocol is paramount:

1. Present Your Plan: Before initiating this complex implementation, you must provide a detailed strategic plan. This plan should outline the next-auth configuration, the structure of your new API endpoints for labels, and the UI/UX for both the label management page and the interactive labeling feature within the email table.
2. Await Approval: I will perform a rigorous review of your plan to ensure its strategic alignment and technical feasibility before granting approval to proceed.

---

### Phase 7

Attention Replit AI Agent:

We have successfully built a robust, authenticated, and interactive application. The next quantum leap in our strategic execution is to transition the "DataBerry" platform from a foundational data viewer into a fully operational, data-driven command center. This phase focuses on activating advanced data manipulation features and establishing a seamless data pipeline with the external Google Apps Script. This will unlock mission-critical value for the Accounting Technician and Administrative Assistant personas, enabling sophisticated data analysis and workflow automation that synergizes with their existing toolchains (e.g., QuickBooks, Sage, Zoho).

I. Strategic Objective

Your directive is to implement a suite of power-user features: an advanced filtering system, a data synchronization trigger, data export capabilities, and a contact management module. This will empower users to move beyond simple data viewing and begin actively analyzing, managing, and leveraging their financial information at scale.

II. Technical Specifications

You are to architect and implement the following mission-critical systems:

1. Advanced Filtering System:

- Component: Build a new, dedicated filtering component (components/advanced-filters.tsx).
- Functionality: This component must empower users to construct complex, multi-conditional queries. For example, a user should be able to filter for emails where (Sender CONTAINS "Amazon") AND (Date is after "2025-01-01") AND (Label IS "Receipts"). The UI must be intuitive, allowing for the dynamic addition and removal of filter rules.
- Integration: The state of this component must be seamlessly integrated with the main email data table, causing it to update in real-time as filters are modified.

2. Data Ingestion & Synchronization:

- Trigger: Implement a "Sync Emails" button, strategically placed in the main application header.
- API Backbone: This button will activate a new API route (app/api/sync/route.ts). The purpose of this route is to serve as the bridge to our Google Apps Script, initiating the data processing pipeline and pulling the latest financial data into our PostgreSQL database.

3. Data Export Functionality:

- Feature: Add an "Export to CSV" button on the main emails page.
- Logic: This export function is business-critical and must respect all active filters applied to the data table. When a user clicks this button, the system will generate and download a CSV file containing only the filtered dataset. This directly supports our accounting and reporting workflows.

4. Contact Management Module:

- New Page: Create a dedicated "Contacts" page at app/contacts/page.tsx.
- Data Display: This page will display a list of contacts automatically extracted from the financial emails. Leverage our reusable data-table component to display key contact information, such as Name, Email, and a count of associated transactions.

III. "Checkpoint-Aware" Protocol

As we architect these more complex, interconnected systems, our disciplined approach is non-negotiable:

1. Present Your Operational Blueprint: Before a single line of code is written, you must submit a comprehensive operational blueprint. This document will detail the UI/UX for the advanced filtering system, the API design for the sync and export functions, and the layout and data-flow for the new contacts page.
2. Await Strategic Greenlight: I will conduct a thorough strategic review of your blueprint to ensure its alignment with our cross-functional requirements and data governance policies. No development will commence until this plan is formally approved.

---

### Phase 8

Attention Replit AI Agent:

The core transactional functionalities of the "DataBerry" platform are now operational. Our next strategic imperative is to unlock the latent value within the aggregated data by activating the main dashboard. We will transform it from a static placeholder into a dynamic, real-time Business Intelligence (BI) and visual analytics hub. This evolution is mission-critical for providing at-a-glance, actionable insights to our Accounting Technician and Administrative Assistant end-users, mirroring the analytical power of their existing toolchains like QuickBooks and Zoho.

I. Strategic Objective

Your directive is to architect and implement the back-end data pipelines and front-end components necessary to power a fully dynamic dashboard. This involves connecting the existing UI elements to live database queries and introducing rich data visualizations to illuminate key financial trends and patterns.

II. Technical Specifications

You are to execute a full-stack implementation of the following dashboard enhancements:

1. Dynamic Stat Card Integration:

- API Layer: Create a new API route (app/api/dashboard/stats/route.ts) that calculates and returns key performance indicators (KPIs) for the authenticated user.
- Calculations: The API should compute:

- Total Emails Processed
- Uncategorized Emails (emails without a label)
- Total Financial Documents (a count of items with specific financial labels)
- Monthly Expense Total (a placeholder value for now, to be implemented later)

- Front-End: Connect the four stat cards on the dashboard page to this API endpoint, ensuring they display the live data upon page load.

2. Visual Analytics - Charting Integration:

- Dependency: Integrate a modern, responsive charting library such as Recharts into the project.
- API Backbone: Create a new API route (app/api/dashboard/charts/route.ts) to serve pre-aggregated data specifically for our new charts.
- Chart Implementation: Build and embed two new chart components onto the dashboard:

- Expenses by Category: A bar chart that displays financial activity categorized by user-defined labels for the current month.
- Transaction Volume Over Time: A line chart that plots the number of financial emails received per day over the last 30 days.

- Styling: The charts must seamlessly integrate with our established brand identity, utilizing the specified color palette and dark theme.

III. "Checkpoint-Aware" Protocol

Given the complexity of data aggregation and visualization, our disciplined, checkpoint-aware methodology is paramount:

1. Present Your Integrated Blueprint: Before development commences, submit a comprehensive blueprint. This document must detail the schema for the new API responses (for both stats and charts) and provide a wireframe or detailed description of how the new charts will be visually integrated into the existing dashboard layout.
2. Await Executive Greenlight: I will perform a thorough review of your proposed architecture and data-flow. No implementation shall begin until the plan has been vetted and formally approved to ensure it aligns with our overarching business intelligence strategy.

Upon completion of this phase, the "DataBerry" application will have evolved from a simple data management tool into a sophisticated analytics platform, providing users with the critical insights needed to make informed financial decisions with speed and confidence.

---
### Phase 9

Attention Replit AI Agent:

We have successfully engineered the core feature set of the "DataBerry" platform. The final frontier in our current strategic scope is to productize this powerful tool, preparing it for a live deployment on the Render platform and empowering users with personalized configuration options. This phase is about ensuring stability, security, and scalability, transforming our development build into a production-grade asset for our end-users.

I. Strategic Objective

Your final directive for this initial build is to implement all necessary configurations for a seamless production deployment and to create a dedicated settings page for user-level customization. This will ensure the application is not only functional but also secure, maintainable, and adaptable to the individual needs of our Accounting Technicians and Administrative Assistants.

II. Technical Specifications

You are to execute the following final implementation tasks to achieve production readiness:

1. Environment Variable Management for Production:

- Review and Consolidate: Conduct a thorough review of the entire codebase to identify all environment variables required for the application to run (e.g., DATABASE_URL, GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, NEXTAUTH_SECRET, etc.).
- Documentation: Create a template environment file, .env.example, that lists all required variables, making it straightforward to configure a new deployment environment on Render. This file should contain placeholder values, not actual secrets.

2. User Settings & Profile Page:

- New Page: Create a new "Settings" page at app/settings/page.tsx.
- Functionality: On this page, build the following user-configurable features:

- Profile Information: Display the authenticated user's name and email address.
- Theme Customization: Even though the default is dark, provide a simple toggle or option for a user to select a "light theme" as a personal preference. This requires creating a light theme variant in tailwind.config.ts.
- Notification Preferences: Add placeholder toggles for email notification settings (e.g., "Weekly Summary Email," "New Document Alerts").
- Account Management: Include a "Delete Account" button that, when clicked, initiates a workflow to remove the user's data from the platform.

3. Deployment Scripts & Configuration:

- Build Command: Ensure the package.json file contains the correct build script (next build) that Render will use to prepare the application for production.
- Start Command: Verify the start script (next start) is present for running the production server.
- Health Checks: Add a basic health check API endpoint at app/api/health/route.ts that returns a 200 OK status, which can be used by Render to monitor the application's health.

III. "Checkpoint-Aware" Protocol

For this final and critical phase, our disciplined approach remains in full force:

1. Present Final Blueprint: Before execution, submit a final, comprehensive blueprint. This document must outline the contents of the .env.example file, the complete UI/UX design and functionality for the new Settings page, and the structure of the health check API response.
2. Await Final Go-Live Approval: I will conduct a meticulous review of this final plan. No production-related code will be implemented until I have given the formal green light, ensuring a secure and successful deployment.

Completing this phase will mark the successful conclusion of our initial development cycle. The "DataBerry" platform will be fully functional, secure, configurable, and ready for its live deployment, delivering tangible, game-changing value to its users from day one.

---
 
### Phase 10

Attention Replit AI Agent:

We have identified a critical gap in our operational capabilities that we must now address. Our next objective is to architect the final, crucial link between our "DataBerry" platform and the user's Google Workspace ecosystem. This phase focuses on implementing the workflow to convert selected emails and their attachments into a standardized PDF format and archive them directly within the user's Google Drive. This is a cornerstone feature for the Accounting Technician persona, providing immutable, easily shareable records for compliance and record-keeping.

I. Strategic Objective

Your directive is to implement the end-to-end functionality that allows a user to trigger a PDF conversion and Google Drive upload for any given financial email. This will involve a seamless, behind-the-scenes orchestration between our Next.js application and the designated Google Apps Script responsible for the heavy lifting of file manipulation.

II. Technical Specifications

You are to implement the following integrated system:

1. UI Trigger:

- In the main emails data table (app/emails/page.tsx), add a new "Actions" column.
- Within this column for each row, include a distinct "Save to Drive" icon-button.

2. Orchestration API Endpoint (app/api/export/drive/route.ts):

- Create a new API route that will be called when the "Save to Drive" button is clicked. This route will receive the messageId of the selected email.
- This API endpoint will act as the orchestrator. Its primary responsibility is to securely call the Google Apps Script web app URL (which will be provided as an environment variable, APPS_SCRIPT_WEB_APP_URL).
- It will pass the messageId and the user's authentication credentials to the Apps Script.
- Upon receiving a successful response from the Apps Script (containing the new Google Drive file URL), this endpoint will update the corresponding record in our attachments table, populating the driveUrl field.

3. UI Feedback Loop:

- Once the API call is complete, the "Save to Drive" button in the UI should be replaced with a new, distinct "View in Drive" icon-button.
- This new button will be a direct link (<a> tag) that opens the newly created PDF in Google Drive in a new tab. This provides immediate, tangible feedback to the user that the operation was successful.

III. "Checkpoint-Aware" Protocol

As this feature involves a critical cross-platform integration, our disciplined protocol is more important than ever:

1. Present Your Integrated Workflow Blueprint: Before implementation, you must provide a detailed blueprint. This document needs to outline the exact payload the Next.js API will send to the Google Apps Script, the expected response format, and the UI state changes (from the initial button to the final link).
2. Await Cross-Platform Synergy Approval: I will perform a meticulous review of this workflow to ensure the integration points are secure, efficient, and robust. No development on this critical path will begin until the plan is formally approved.

Thank you for your diligence. Integrating this feature will significantly enhance the strategic value of the "DataBerry" platform, transforming it into a truly indispensable tool for financial document management.